/*
We downloaded 3 different datasets for HydroPowerGeneration, WindPowerGeneration and SolarPowerGeneration from Fingrid. The file is in JSON format
*/

package com.rockthejvm

import java.time.LocalDate
import java.time.YearMonth

import scala.io.Source
import java.io.{BufferedWriter,FileWriter}
import java.time.format.DateTimeFormatter
import java.time.LocalDateTime
import java.time.format.DateTimeParseException
import java.io.File
import org.json4s._
import org.json4s.native.JsonMethods._

//First defining a case class to represent renewable energy data
case class RenewableEnergyData(datasetId: Int, startTime: LocalDateTime, endTime: LocalDateTime, value: Double)
object REPS_2024 extends App{

  /*
  Use case 1: The system should be designed to monitor and control the power plant's renewable
  energy sources, including solar panels, wind turbines, and hydropower.
  */

  /*
  Use case 2: The system should be capable of collecting data related to the energy generated by
  renewable sources and storing it in a file.
  */

  //For this use case, Users are asked information about energy data and data are
  //stored in respective files.

  def collectEnergyValue(source: String):Unit = {
    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm")

    println("Enter datasetId:")
    val datasetId = scala.io.StdIn.readLine()

    //Asking user for date and time and implementing error HANDLING.
    println("Enter start time (YYYY-MM-DDTHH:MM):")
    var startTime: LocalDateTime = null
    var correctStartTime = false
    while (!correctStartTime) {
      try {
        startTime = LocalDateTime.parse(scala.io.StdIn.readLine(), formatter)
        correctStartTime = true
      } catch {
        case e: DateTimeParseException =>
          println("Invalid format. Please enter in YYYY-MM-DDTHH:MM format.")
      }
    }

    println("Enter end time (YYYY-MM-DDTHH:MM):")
    var endTime: LocalDateTime = null
    var correctEndTime = false
    while (!correctEndTime) {
      try {
        endTime = LocalDateTime.parse(scala.io.StdIn.readLine(), formatter)
        correctEndTime = true
      } catch {
        case e: DateTimeParseException =>
          println("Invalid format. Please enter in YYYY-MM-DDTHH:MM format.")
      }
    }
    println("Enter the value:")
    val value = scala.io.StdIn.readDouble()

    // Creating the energy data in text format
    val data = s"datasetId: $datasetId,startTime: $startTime,endTime: $endTime,value: $value"

    // Writing the data to the corresponding files
    val writer = new BufferedWriter(new FileWriter(s"${source}Energy.txt",true))
    writer.write(data)
    writer.newLine()
    writer.close()

    println(s"Energy information collected and stored in ${source}Energy.txt")
  }

  //Asking user for energy related information
  var repeat = true
  while (repeat) {
    println("Do you want to add wind energy, solar energy, or hydro energy? (Type s for solar, w for wind, h for hydro, or e to exit):")
    val sourceChoice = scala.io.StdIn.readLine()

    // Process user's choice and call collectEnergy function accordingly
    sourceChoice match {
      case "s" => collectEnergyValue("Solar")
      case "w" => collectEnergyValue("Wind")
      case "h" => collectEnergyValue("Hydro")
      case "e" => repeat = false // Exit the loop if 'e' is entered
      case _ => println("Invalid choice.")
    }
  }

  /*
  Use case 3: The system should provide a view of the power plant's energy generation and storage
  capacity, allowing operators to adjust the power plant's operation as needed. This
  view should show the data stored in the file.
  */

  /*
  Use case 4: The system should be able to analyse the data collected from renewable sources. It
  should be possible to filter the data on an hourly, daily, weekly and monthly basis. It
  should be possible to sort the data where possible. It must allow a user to search for
  required data stored in the system.
  Data Analysis should include: Mean, Median, Mode, Range, and Midrange
  */
  // Creating a function to parse a line of data from the file into RenewableEnergyData
  def parseLine(line: String): RenewableEnergyData = {
    val fields = line.trim.split(",")
    val datasetId = fields(0).split(":")(1).trim.toInt
    val startTime = LocalDateTime.parse(fields(1).split(":")(1).trim + ":" + fields(1).split(":")(2).trim, DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm"))
    val endTime = LocalDateTime.parse(fields(2).split(":")(1).trim + ":" + fields(2).split(":")(2).trim, DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm"))
    val value = fields(3).split(":")(1).trim.toDouble
    RenewableEnergyData(datasetId, startTime, endTime, value)
  }


  // Creating a fununction to read data from file (for demo purpose: we use "SolarEnergy.txt" and return as a list of RenewableEnergyData
  def readData(filePath: String): List[RenewableEnergyData] = {
    val bufferedSource = Source.fromFile(filePath)
    val dataList = bufferedSource.getLines().map(parseLine).toList
    bufferedSource.close
    dataList
  }

  // Creating a function to filter data based on user-specified criteria(data filtering)
  def filterData(data: List[RenewableEnergyData], filter: String, value: Option[Any] = None): List[RenewableEnergyData] = {
    filter match {
      case "hourly" =>
        val hourStart = LocalDateTime.parse(value.get.toString, DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm"))
        val hourEnd = hourStart.plusHours(1)
        data.filter(d => (d.startTime.isEqual(hourStart) || d.startTime.isAfter(hourStart)) && d.startTime.isBefore(hourEnd))
      case "daily" =>
        val date = LocalDate.parse(value.get.toString, DateTimeFormatter.ofPattern("yyyy-MM-dd"))
        data.filter(d => d.startTime.toLocalDate == date)
      case "weekly" =>
        val weekStart = LocalDate.parse(value.get.toString, DateTimeFormatter.ofPattern("yyyy-MM-dd"))
        val weekEnd = weekStart.plusDays(7)
        data.filter(d => d.startTime.toLocalDate.isEqual(weekStart) || d.startTime.toLocalDate.isBefore(weekEnd))
      case "monthly" =>
        val month = YearMonth.parse(value.get.toString, DateTimeFormatter.ofPattern("yyyy-MM"))
        data.filter(d => d.startTime.getMonthValue == month.getMonthValue)
      case _ => throw new IllegalArgumentException("Invalid filter provided")
    }
  }


  //Reading data from "SolarEnergy.txt"
  val sampleData = readData("SolarEnergy.txt")


  var continue = true
  while (continue) {
    // Asking the user for filter criteria
    println("Enter filter criteria: hourly, daily, weekly, monthly ? Type e to exit")
    val filter = scala.io.StdIn.readLine()

    if (filter == "e") {
      continue = false
    }
    else {
      // Printing the value based on the selected filter
      val value = filter match {
        case "hourly" =>
          println("Enter hour (format: yyyy-MM-dd'T'HH:mm):")
          Some(scala.io.StdIn.readLine())
        case "daily" =>
          println("Enter date (format: yyyy-MM-dd):")
          Some(scala.io.StdIn.readLine())
        case "weekly" =>
          println("Enter start date of the week (format: yyyy-MM-dd):")
          Some(scala.io.StdIn.readLine())
        case "monthly" =>
          println("Enter month (format: yyyy-MM):")
          Some(scala.io.StdIn.readLine())
        case e => //Exit the loop
          continue = false
          None
        case _ => None
      }

      // Filter data based on user input
      val filteredData = filterData(sampleData, filter, value)

      // Print filtered data
      println("Filtered Data:")
      filteredData.foreach(println)
    }

    //Data Analysis
    //Calculating mean
    def meanCalculation(values: List[Double]): Double = {
      values.sum / values.length
    }

    def dataAnalysis(values: List[Double]): Unit = {
      println(s"Mean: ${meanCalculation(values)}")
    }

    val values = sampleData.map(_.value)

    dataAnalysis(values)
  }


  /*
  Use case 5:  The system should be able to detect and handle issues with renewable energy sources,
  such as low energy output, and equipment malfunction, generating alerts for the
  operators accordingly
   */

}
